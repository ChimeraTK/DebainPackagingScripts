#!/usr/bin/python

import debian.debian_support
import urllib
import subprocess
import os
import sys
import time
import tempfile
import shutil

# function for resolving dependencies from a Packages file
# returns a dictionary: "name" -> "version"
def resolveDeps(dependencies, filename):

  # open Packages file and parse it
  PackageFile = debian.debian_support.PackageFile(filename)
  dependency_versions = {}

  # search for dependencies
  for Package in PackageFile:
    for dependency in dependencies:
      PackageAsDictionary = dict(Package)
      if dependency == PackageAsDictionary["Package"]:
        dependency_versions[dependency] = PackageAsDictionary["Version"]
  
  return dependency_versions


# output usage
if len(sys.argv) != 5 :
  print("Usage: ./configureRelease <project_name> <project_version> <distribution_codename> <architecture>")
  print("Example: ./configureRelease DOOCSwrappers 0.5.0 xenial amd64")
  sys.exit()

# parse command line arguments
project = sys.argv[1]
tagversion = sys.argv[2]
version = tagversion
if tagversion[0:1] == "v":
  version = tagversion[1:]
splitversion = version.split(".")
epoch = splitversion[0]+"."+splitversion[1]
patchlevel = splitversion[2]
codename = sys.argv[3]
arch = sys.argv[4]

# checkout or update the control git repository
if not os.path.isdir("DebianBuildVersions"):
  subprocess.call(["git", "clone", "-q", "git@github.com:ChimeraTK/DebianBuildVersions.git"])
else:
  os.chdir("DebianBuildVersions")
  subprocess.call(["git", "pull", "-q"])
  os.chdir("..")

# check if project is known
if not os.path.isfile("DebianBuildVersions/"+project+"/CONFIG"):
  print("The project "+project+" is not known.")
  sys.exit(1)

# preset optional config variables
config = {}
#config["Dependencies-dev"] = ""

# read config file
configfile = open("DebianBuildVersions/"+project+"/CONFIG",'r').read().splitlines()
line_counter=0
for line in configfile:
  line_counter = line_counter+1
  if line.strip() == "" or line.strip()[0:1] == "#":
    continue
  try:
    ( key, value ) = line.split(":", 1)
  except (ValueError):
    print("Error parsing file 'DebianBuildVersions/"+project+"/CONFIG' in line "+str(line_counter))
    sys.exit(1)
  config[key.strip()] = value.strip()

hasPackages = config["Has-packages"].split(" ")

# check for mandatory variables in the config
if not "Dependencies" in config:
  print("Missing variable 'Dependencies' in CONFIG file")
  sys.exit(1)
if not "SourceURI" in config:
  print("Missing variable 'SourceURI' in CONFIG file")
  sys.exit(1)
if not "Maintainer" in config:
  print("Missing variable 'Maintainer' in CONFIG file")
  sys.exit(1)
if not "Section" in config:
  print("Missing variable 'Section' in CONFIG file")
  sys.exit(1)
if not "Has-packages" in config:
  print("Missing variable 'Has-packages' in CONFIG file")
  sys.exit(1)
if not "License" in config:
  print("Missing variable 'License' in CONFIG file")
  sys.exit(1)

# check if version is a valid tag
workdir = os.getcwd()
tempdir = tempfile.mkdtemp("configureRelease")
os.chdir(tempdir)
ret = subprocess.call(["git", "clone", "-q", config["SourceURI"], "."])
if ret != 0:
  print("Cannot access source repository.")
  os.chdir(workdir)
  shutil.rmtree(tempdir)
  sys.exit(1)
ret = subprocess.call(["git", "checkout", "-q", "tags/"+tagversion])
if ret != 0:
  print("Version "+version+" does not exist in the source repository.")
  print("List of known versions:")
  ret = subprocess.call(["git", "tag"])
  os.chdir(workdir)
  shutil.rmtree(tempdir)
  sys.exit(1)
os.chdir(workdir)
shutil.rmtree(tempdir)

# output generic information
print("Project: "+project)
print("Source tag name: "+tagversion)
print("Version: "+version)
print("Epoch version: "+epoch)
print("Distribution: "+codename)
print("Architecture: "+arch)

# parse lists of dependencies
dependencies = config["Dependencies"].split(" ")
if "dev" in hasPackages:
  dependencies_dev = config["Dependencies-dev"].split(" ")
else:
  dependencies_dev = {}

print("Searching for dependencies...")

# download Packages file from the DESY DOOCS apt repositories
subprocess.call(["wget", "-q", "http://doocspkgs.desy.de/pub/doocs/dists/"+codename+"/main/binary-"+arch+"/Packages", "-O", "Packages.DESY"])

# download Packages file from Ubuntu repositories and unpack
subprocess.call(["wget", "-q", "http://de.archive.ubuntu.com/ubuntu/dists/"+codename+"/main/binary-"+arch+"/Packages.gz", "-O", "Packages.MAIN.gz"])
subprocess.call(["gunzip", "-f", "Packages.MAIN.gz"])

# download Packages file from Ubuntu repositories and unpack
subprocess.call(["wget", "-q", "http://de.archive.ubuntu.com/ubuntu/dists/"+codename+"/universe/binary-"+arch+"/Packages.gz", "-O", "Packages.UNIVERSE.gz"])
subprocess.call(["gunzip", "-f", "Packages.UNIVERSE.gz"])

# update the locake package repository
subprocess.call(['sudo bash -c "cd /var/cache/pbuilder/result ; apt-ftparchive packages . > Packages"'], shell=True)

# parse all sources
dependency_versions_main = resolveDeps(dependencies, "Packages.MAIN")
dependency_versions_universe = resolveDeps(dependencies, "Packages.UNIVERSE")
dependency_versions_desy = resolveDeps(dependencies, "Packages.DESY")
dependency_versions_local = resolveDeps(dependencies, "/var/cache/pbuilder/result/Packages")

# merge the found dependencies with priority, and check for unfound dependencies
print("")
print("List of dependencies:")
dependency_versions = {}
is_using_local = False
for dependency in dependencies:
  if dependency in dependency_versions_local:
    dependency_versions[dependency] = dependency_versions_local[dependency]
    print("  "+dependency+" (= "+dependency_versions[dependency]+") from *** LOCAL ***")
    is_using_local = True
  elif dependency in dependency_versions_main:
    dependency_versions[dependency] = dependency_versions_main[dependency]
    print("  "+dependency+" (= "+dependency_versions[dependency]+") from ubuntu/main")
  elif dependency in dependency_versions_universe:
    dependency_versions[dependency] = dependency_versions_universe[dependency]
    print("  "+dependency+" (= "+dependency_versions[dependency]+") from ubuntu/universe")
  elif dependency in dependency_versions_desy:
    dependency_versions[dependency] = dependency_versions_desy[dependency]
    print("  "+dependency+" (= "+dependency_versions[dependency]+") from desy/main")
  else:
    sys.exit("Dependency "+dependency+" cannot be found in any of the apt repository!")

# print warning if using the local repository
if is_using_local:
  print("")
  print("*** WARNING ***")
  print("You are building against packages in your local /var/cache/pbuilder/result which have not yet been published!")

# form the directory name for the build version
version_base_dir = project+"/"+epoch+"/"+codename+"-"+arch
dependency_dir = version_base_dir

# create list of dependencies with versions
build_depends=""
for dependency in dependencies:
  dependency_dir = dependency_dir+"/"+dependency+"-"+dependency_versions[dependency]
  build_depends += dependency+" (= "+dependency_versions[dependency]+"), "
build_depends = build_depends[:-2]

dev_depends=""
for dependency in dependencies_dev:
  dev_depends += dependency+" (= "+dependency_versions[dependency]+"), "
dev_depends = dev_depends[:-2]

#print("Dependency ID string: "+dependency_dir)
  
# determine build number
print("")
if not os.path.isfile("DebianBuildVersions/"+dependency_dir+"/BUILD_NUMBER"):
  # the package has not yet been built with these dependencies
  if not os.path.isfile("DebianBuildVersions/"+version_base_dir+"/LAST_BUILD"):
    print("The package was not yet build in this version for this distribution")
    build_number = 1
    # create the dependency directory with the BUILD_NUMBER file in it
    os.makedirs("DebianBuildVersions/"+dependency_dir)
    f = open("DebianBuildVersions/"+dependency_dir+"/BUILD_NUMBER", 'w')
    f.write(str(build_number))
    f.close()
    # create the link file to the last build
    f = open("DebianBuildVersions/"+version_base_dir+"/LAST_BUILD", 'w')
    f.write(dependency_dir)
    f.close()
  else:
    print("The package was already built in this version for this distribution with different dependencies")
    # determine the last build's dependency directory
    f = open("DebianBuildVersions/"+version_base_dir+"/LAST_BUILD", 'r')
    last_build = f.readline().rstrip('\n')
    f.close()
    # determine the build number of the last build, increment by one
    f = open("DebianBuildVersions/"+last_build+"/BUILD_NUMBER", 'r')
    build_number = int(f.readline()) + 1
    f.close()
    # create the dependency directory with the BUILD_NUMBER file in it
    os.makedirs("DebianBuildVersions/"+dependency_dir)
    f = open("DebianBuildVersions/"+dependency_dir+"/BUILD_NUMBER", 'w')
    f.write(str(build_number))
    f.close()
    # create the link file to the last build
    f = open("DebianBuildVersions/"+version_base_dir+"/LAST_BUILD", 'w')
    f.write(dependency_dir)
    f.close()
else:    
  print("The package was already built in this version for this distribution with the same dependencies")
  # just read the build number from the dependency directory
  f = open("DebianBuildVersions/"+dependency_dir+"/BUILD_NUMBER", 'r')
  build_number = int(f.readline())
  f.close()

print("Build number: "+str(build_number))
  
# extend the config by dynamic variables
config["project"] = project
config["package-basename"] = "lib"+project.lower()
config["version"] = version
config["tagversion"] = tagversion
config["buildversion"] = codename+str(build_number)
config["soversion"] = epoch+config["buildversion"]
config["debversion"] = epoch.replace(".","-")+"-"+config["buildversion"]
config["package-version"] = config["soversion"]+"."+patchlevel
config["build-depends"] = build_depends
config["dev-depends"] = dev_depends
config["distribution"] = codename
config["architecture"] = arch
config["package-message"] = "Debian package for the "+project+" library version "+version
#print(config)

# create directory holding the debian control files
controldir="DebianBuildVersions/"+version_base_dir+"/"+str(build_number)
if not os.path.isdir(controldir):
  os.makedirs(controldir)
if not os.path.isdir(controldir+"/source"):
  os.makedirs(controldir+"/source")

# list of files to be processed (static part)
filelist = [ "makeDebianPackage.config", "compat", "rules", "source/format", "control.src" ]

# list of files to be processed for each package
for package in hasPackages:
  filelist.append("control."+package.strip())
  filelist.append("package-"+package.strip()+".install")

# copyright file
filelist.append("copyright."+config["License"])

# if we have a lib package, add the shlib file
if "lib" in hasPackages:
  filelist.append("package-lib.shlib")
  
#print filelist

# replace config variables in files
for filna in filelist:
  # read file into string
  content = open("templates/"+filna).read()
  # replace all variables
  for var in config.keys():
    content = content.replace("#"+var+"#", config[var])
  # check for unknown variables which have not been replaced
  if content.find("#") != -1:
    pos1 = content.find("#")
    pos2 = content.find("#",pos1+1)
    # two consecutive # are not a variable but will be replaced with a single #, so ignore it
    if pos2 > pos1+1:
      print "File "+filna+" has an unknown variable: "+content[pos1:pos2+1]
      sys.exit(1)
  # replace ## with #, so we can still write single # if needed
  content = content.replace("##", "#")
  # write out the resulting file
  f = open(controldir+"/"+filna,"w")
  f.write(content)
  f.close()

# create the merged control file and remove the parts
content = open(controldir+"/control.src").read()
for package in hasPackages:
  content += open(controldir+"/control."+package).read()
f = open(controldir+"/control","w")
f.write(content)
f.close()
subprocess.call(["rm "+controldir+"/control.*"], shell=True)

# rename files which need a different name
os.rename(controldir+"/copyright."+config["License"], controldir+"/copyright")
if "lib" in hasPackages:
  os.rename(controldir+"/package-lib.install", controldir+"/"+config["package-basename"]+config["debversion"]+".install")
  os.rename(controldir+"/package-lib.shlib",   controldir+"/"+config["package-basename"]+config["debversion"]+".shlib")
if "dev" in hasPackages:
  os.rename(controldir+"/package-dev.install", controldir+"/"+config["package-basename"]+"-dev.install")
if "doc" in hasPackages:
  os.rename(controldir+"/package-doc.install", controldir+"/"+config["package-basename"]+"-doc.install")

# make rules file executable
subprocess.call(["chmod", "+x", controldir+"/rules"])

# commit the changes to git
#os.chdir("DebianBuildVersions")
#subprocess.call(["git", "add", "-a" , "."])
#subprocess.call(["git", "commit", "-a" , "-m", "build "+str(build_number)+" of "+version_base_dir])
#subprocess.call(["git", "push"])
#os.chdir("..")

# output the command to build the package
print("")
print("To build the package, run the following command:")
print("./makeDebianPackage "+controldir)
